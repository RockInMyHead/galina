// Speech-to-Text routes
const express = require('express');
const multer = require('multer');
const router = express.Router();
const openaiAdapter = require('../services/openai/adapter');
const config = require('../config');

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ multer –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤
const storage = multer.memoryStorage();
const upload = multer({
  storage: storage,
  limits: {
    fileSize: 100 * 1024 * 1024, // 100MB limit
  },
  fileFilter: (req, file, cb) => {
    console.log('üéµ Multer file filter:', {
      fieldname: file.fieldname,
      originalname: file.originalname,
      mimetype: file.mimetype
    });
    cb(null, true);
  }
});

// Speech to Text endpoint - supports both multipart and raw binary
const sttHandler = async (req, res) => {
  try {
    console.log('üé§ STT Request received');
    console.log('üìã Content-Type:', req.headers['content-type']);

    let audioBuffer;
    let mimeType = 'audio/wav';
    let fileName = 'recording.wav';

    // Check if it's multipart/form-data (multer processed)
    if (req.file) {
      console.log('üìÅ Received as multipart/form-data');
      audioBuffer = req.file.buffer;
      mimeType = req.file.mimetype;
      fileName = req.file.originalname;
    }
    // Check if it's raw body (express raw parser for /stt/raw)
    else if (req.body && Buffer.isBuffer(req.body)) {
      console.log('üìÅ Received as raw body buffer (express.raw)');
      audioBuffer = req.body;
      mimeType = req.headers['content-type'] || 'audio/wav';
      fileName = req.headers['content-disposition']?.match(/filename="([^"]+)"/)?.[1] || 'recording.wav';
    }
    // Check if it's raw binary data (fallback for manual streaming)
    else if (req.headers['content-type'] && req.headers['content-type'].includes('audio/')) {
      console.log('üìÅ Received as raw binary data (manual streaming)');
      audioBuffer = Buffer.from(await new Promise((resolve, reject) => {
        const chunks = [];
        req.on('data', chunk => chunks.push(chunk));
        req.on('end', () => resolve(Buffer.concat(chunks)));
        req.on('error', reject);
      }));
      mimeType = req.headers['content-type'];
      fileName = req.headers['content-disposition']?.match(/filename="([^"]+)"/)?.[1] || 'recording.wav';
    }
    else {
      console.log('‚ùå No audio data found in request');
      console.log('üìã Request keys:', Object.keys(req));
      console.log('üìã Body type:', typeof req.body);
      return res.status(400).json({ error: 'No audio data received. Expected multipart/form-data with "audio" field or raw binary data.' });
    }

    console.log('üéµ Audio processing info:', {
      bufferSize: audioBuffer.length,
      mimeType,
      fileName,
      sizeMB: (audioBuffer.length / 1024 / 1024).toFixed(2)
    });

    const apiKey = config.OPENAI_API_KEY;
    console.log('üîë API Key check:', {
      exists: !!apiKey,
      length: apiKey?.length,
      isEmpty: !apiKey || apiKey.trim() === '',
      startsWith: apiKey?.substring(0, 15) + '...' || 'undefined',
      envVarSet: 'OPENAI_API_KEY' in process.env,
      rawValue: apiKey ? `"${apiKey}"` : 'null'
    });

    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –µ—Å–ª–∏ –∫–ª—é—á —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –Ω–æ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ–º–æ
    if (apiKey && (apiKey.trim() === '' || apiKey.length < 20 || (!apiKey.startsWith('sk-') && !apiKey.startsWith('sk-proj-') && !apiKey.startsWith('sk-svc-')))) {
      console.log('üö® API key exists but invalid - returning demo response');
      return res.json({
        success: true,
        text: '–ü—Ä–∏–≤–µ—Ç! –Ø –ì–∞–ª–∏–Ω–∞, –≤–∞—à AI-—é—Ä–∏—Å—Ç. API –∫–ª—é—á OpenAI –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω. –î–ª—è –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π OPENAI_API_KEY –≤ —Ñ–∞–π–ª–µ api/.env'
      });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∫–ª—é—á–∞
    if (!apiKey || apiKey.trim() === '' || apiKey === 'sk-your-actual-openai-api-key-here') {
      console.log('‚ö†Ô∏è No valid API key configured - returning demo response');
      console.log('üí° To enable real STT, create api/.env file with: OPENAI_API_KEY=your_actual_key_here');
      return res.json({
        success: true,
        text: '–ü—Ä–∏–≤–µ—Ç! –Ø –ì–∞–ª–∏–Ω–∞, –≤–∞—à AI-—é—Ä–∏—Å—Ç. –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, API –∫–ª—é—á OpenAI –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –ø–æ—ç—Ç–æ–º—É —è —Ä–∞–±–æ—Ç–∞—é –≤ –¥–µ–º–æ-—Ä–µ–∂–∏–º–µ. –î–ª—è –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã —Å –≥–æ–ª–æ—Å–æ–º —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ OPENAI_API_KEY –≤ —Ñ–∞–π–ª–µ api/.env'
      });
    }

    console.log('üì§ About to send to OpenAI - final check:');
    console.log('   API Key exists:', !!apiKey);
    console.log('   API Key length:', apiKey?.length);
    console.log('   API Key starts with:', apiKey?.substring(0, 15) + '...');

    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –µ—Å–ª–∏ –∫–ª—é—á –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ–º–æ
    if (!apiKey || apiKey.length < 20 || (!apiKey.startsWith('sk-') && !apiKey.startsWith('sk-proj-'))) {
      console.log('üö® API key validation failed - returning demo response');
      return res.json({
        success: true,
        text: '–ü—Ä–∏–≤–µ—Ç! –Ø –ì–∞–ª–∏–Ω–∞, –≤–∞—à AI-—é—Ä–∏—Å—Ç. API –∫–ª—é—á OpenAI –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –∫–ª—é—á–∞ –≤ —Ñ–∞–π–ª–µ api/.env'
      });
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –ø–æ–¥—Ö–æ–¥ —Å fetch –∏ FormData
    const result = await openaiAdapter.createTranscription(audioBuffer, {
      language: 'ru',
      response_format: 'json'
    });

    console.log('‚úÖ OpenAI STT successful:', {
      text: result.text,
      language: result.language,
      duration: result.duration
    });

    if (!result.text || result.text.trim().length === 0) {
      console.warn('‚ö†Ô∏è OpenAI returned empty text');
      return res.json({
        success: true,
        text: '–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ä–µ—á—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≥–æ–≤–æ—Ä–∏—Ç—å —á–µ—Ç—á–µ.'
      });
    }

    res.json({
      success: true,
      text: result.text.trim()
    });

  } catch (error) {
    console.error('STT Server error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      details: error.message
    });
  }
};

// Routes for STT with different upload methods
router.post('/', upload.single('audio'), sttHandler); // multipart/form-data
// Raw binary route will be handled in main server with express.raw middleware

module.exports = { router, sttHandler };
